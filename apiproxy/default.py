from sanic import Sanic
from sanic import response

import sexpdata
from sexpdata import car,cdr,Symbol

from cooltools import with_multi_args

from time import strftime, gmtime


import smoked_rpc

proxy_app = Sanic()

import config


# lisp magic
# literally - all software is magic, because it causes change in reality in accordance with will
data_file = open('data.lisp')
data_model = sexpdata.load(data_file)
data_file.close()

def dictalise(sexp):
    """ Turn a deserialised s-expression into a python dict
    """
    retval = {}
    for entry in cdr(sexp):
        if len(cdr(entry)) > 1:
           retval[car(entry).value()] = cdr(entry)
        else:
           retval[car(entry).value()] = car(cdr(entry))
    return retval

# TODO - switch from rpc method to some more generic method for data source

def gen_entity_multi_handler(entity_dict):
    defargs = []
    has_count = False
    rpc_method_name = car(entity_dict['rpc_method']).value()
    for arg in car(cdr(entity_dict['rpc_method'])):
        if type(arg) is sexpdata.Symbol:
           if arg.value() == '!count':
              has_count = True
           else:
              defargs.append(arg.value())
        else:
          defargs.append(arg)
    rpc_method = with_multi_args(getattr(smoked_rpc,rpc_method_name),defargs)
    max_count  = entity_dict['max_datums']
    def handler_with_count(request):
        if 'count' in request.raw_args.keys():
           count = int(request.raw_args['count'])
           if count > max_count: count=max_count
        else:
           count = max_count
        resp = rpc_method(count)
        return response.json(resp)
    def handler_without_count(request):
        resp = rpc_method()
        return response.json(resp)
    if has_count:
       return handler_with_count
    else:
       return handler_without_count

def gen_entity_single_handler(entity_dict):
    defargs = []
    has_id = False
    rpc_method_name = car(entity_dict['rpc_method']).value()
    for arg in car(cdr(entity_dict['rpc_method'])):
        if type(arg) is sexpdata.Symbol:
           if arg.value() == '!id':
              has_id = True
           else:
              defargs.append(arg.value())
        else:
           defargs.append(arg)
    rpc_method = with_multi_args(getattr(smoked_rpc,rpc_method_name),defargs)
    def handler_with_id(request,name):
        resp = rpc_method(name)
        return response.json(resp)
    def handler_without_id(request):
        resp = rpc_method()
        return response.json(resp)
    if has_id: return handler_with_id
    return handler_without_id

custom_handlers = {}

def get_blog_posts(request,name):
    count = 10
    if request.raw_args.has_key('count'):
       count = request.raw_args['count']
       if count > 10: count = 10
    retval = []
    for p in smoked_rpc.get_discussions_before_date(username,"",strftime('%Y-%m-%dT%H:%M:%S',gmtime()),"10"):
        retval.append({'permlink':p['permlink'],'id':p['id']})
    return response.json(retval)

custom_handlers['get_blog_posts'] = get_blog_posts

def add_entity(sanic_app,entity_name,entity_dict):
    if 'custom_handler' in entity_dict.keys():
       if 'unique_id' in entity_dict.keys():
          sanic_app.add_route(custom_handlers[entity_dict['custom_handler'].value()],''.join(('/',entity_name,'/','<%s>' % entity_dict['unique_id'].value())))
       else:
          sanic_app.add_route(custom_handlers[entity_dict['custom_handler'].value()],''.join(('/',entity_name)))
       return
    if 'max_datums' in entity_dict.keys():
       sanic_app.add_route(gen_entity_multi_handler(entity_dict),''.join(('/',entity_name)))
    else:
       sanic_app.add_route(gen_entity_single_handler(entity_dict),''.join(('/',entity_name, '/<%s>' % entity_dict['unique_id'].value())))

for entity in data_model:
    add_entity(proxy_app,car(entity).value(),dictalise(entity))


#@proxy_app.route('/witness/<witness_name>')
#async def get_witness(request,witness_name):
#      witness_data = smoked_rpc.get_witness_data(witness_name)
#      return response.json(witness_data)

@proxy_app.route('/post/<author>/<post>')
async def get_post(request,author,post):
      pass

#@proxy_app.route('/network')
#async def get_network_data(request):
#      return response.json(smoked_rpc.get_network_data())

@proxy_app.route('/')
async def smoked(request):
      # TODO - replace this with a nifty autogenerated documentation + API explorer thing
      return response.text('This is an API server, read the documentation to use it')

if __name__ == "__main__":
   proxy_app.run(host="0.0.0.0", port=8000)
